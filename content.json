{"meta":{"title":"孤失狐的博客","subtitle":"勿忘初心","description":"","author":"孤失狐","url":"http://gushihu1.com","root":"/"},"pages":[{"title":"","date":"2020-03-01T13:17:51.091Z","updated":"2020-03-01T13:17:51.091Z","comments":true,"path":"404.html","permalink":"http://gushihu1.com/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"react\":{\"opacity\":1},\"log\":false});"},{"title":"标签","date":"2020-03-02T11:04:09.000Z","updated":"2020-03-02T11:10:41.454Z","comments":true,"path":"tags/index.html","permalink":"http://gushihu1.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-02T11:05:29.000Z","updated":"2020-03-02T11:10:23.873Z","comments":true,"path":"categories/index.html","permalink":"http://gushihu1.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JDBC","slug":"JDBC","date":"2020-03-01T12:28:15.000Z","updated":"2020-03-08T13:14:44.409Z","comments":true,"path":"2020/03/01/JDBC/","link":"","permalink":"http://gushihu1.com/2020/03/01/JDBC/","excerpt":"摘要","text":"摘要 JDBC1.1获取连接 数据库url: ==url=“ jdbc:mysql://localhost:3306/数据库名 ”== 配置信息 用户名： 密码： 驱动 1.1.1 配置文件获取连接1234url=jdbc:mysql://localhost/testjdbc?serverTimezone=UTCusername=rootpassword=admindriverClassName=com.mysql.cj.jdbc.Driver 1234567891011121314151617public static Connection getConnection1() throws Exception &#123; //1.读取配置文件中的四个基本信息 InputStream is = GetConnection1.class.getClassLoader().getResourceAsStream(\"配置文件路径\"); Properties pros =new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2.加载驱动 Class.forName(driverClass); //3.获取连接 Connection conn = DriverManager.getConnection(url,user,password); return conn; &#125; 1.2 关闭资源123456789101112131415161718192021222324public static void closeResource1(Connection conn, Statement ps,ResultSet rs) &#123; try &#123; if ((ps != null))&#123; ps.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; try &#123; if (conn != null)&#123; conn.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; try &#123; if (rs != null)&#123; rs.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; 1.3 PreparedStatement和Statement1.3.1 Statement存在的问题 需要拼写SQL语句 存在SQL注入问题 1.3.2 Statement对数据库进行操作123String user = \"张三\";String password = \"zhangsan\";String sql = \"SELECT USER,PASSWORD FROM user_table WHERE USER = '\"+user+\"' AND PASSWORD = '\"+password+\"'\"; 1.3.3 PreparedStatement对数据库进行操作1.3.3.1 增删改1234567891011121314151617//4.预编译SQL语句， String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; PreparedStatement ps = conn.prepareStatement(sql); //5.填充占位符 ps.setString(1,\"哪吒\"); ps.setString(2,\"nezha@qq.com\"); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); java.util.Date date = sdf.parse(\"1000-01-01\"); ps.setDate(3, new Date(date.getTime())); //6.执行操作 ps.execute(); //7.资源的关闭 ps.close(); conn.close(); 1.3.3.2 通用的增删改1234public void PreparedStatementTest()&#123; String sql = \"delete from customers where id = ?\"; update(sql,3,...);//有几个问号，写几个参数 &#125; 12345678910111213141516171819202122public void update(String sql, Object ...args) &#123; Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库 connection = getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 closeResource1(connection,preparedStatement,null); &#125; &#125; 1.3.3.3 通用查询1.3.3.3.1 返回表中的一条数据1234StatementTest st = new StatementTest(); String sql = \"select id,name,email from customers where id=?\"; Customer customer = st.query1(Customer.class, sql, 2); System.out.println(customer); 12345678910111213141516171819202122232425262728293031323334353637383940public &lt;T&gt; T query1(Class&lt;T&gt; clazz,String sql,Object...args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; connection = getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); if (resultSet.next())&#123; T t = clazz.newInstance(); for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125; 1.3.3.3.2 返回多行数据1234StatementTest st = new StatementTest(); String sql = \"select id,name,birth from student where id&lt;?\"; List&lt;Student&gt; list = st.query2(Student.class, sql, 4); list.forEach(System.out::println); 1.3.3.3.3 查所有1234StatementTest st &#x3D; new StatementTest(); String sql &#x3D; &quot;select id,name,birth from student &quot;; List&lt;Student&gt; list &#x3D; st.query2(Student.class, sql); list.forEach(System.out::println); 123456789101112131415161718192021222324252627282930313233343536373839404142public &lt;T&gt; List&lt;T&gt; query2(Class&lt;T&gt; clazz, String sql, Object...args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; connection = getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while (resultSet.next())&#123; T t = clazz.newInstance(); //处理结果集数据中的每一个列：给t对象指定的属性赋值 for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125; 通用特殊值查询 123456789101112131415161718192021//通用特殊值查询 public &lt;E&gt; E getValue(Connection connection,String sql,Object...args) &#123; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt;args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; resultSet = preparedStatement.executeQuery(); if (resultSet.next())&#123; return (E) resultSet.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(null,preparedStatement,resultSet); &#125; return null; &#125; 1.3.3.4 插入图片12345678910public void testInsert() throws Exception&#123; Connection connection = JDBC.getConnection1(); String sql = \"insert into student(id,photo)values (?,?)\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setObject(1,4); FileInputStream is = new FileInputStream(\"F:\\\\red-pagoda-temple-3380967.jpg\"); preparedStatement.setBlob(2,is); preparedStatement.execute(); JDBC.closeResource1(connection,preparedStatement,null); &#125; 1.3.4Statement和PreparedStatement区别 解决了Statement的拼串 解决了SQL注入问题 PreparedStatement可以操作Blob的数据 PreparedStatement可以实现更高效的批量操作 1.4 批量插入 ddBatch() excuteBatch() clearBatch() 1234567891011121314//设置不允许自动提交数据 conn.setAutoCommit(false); for (int i = 1;i &lt;= 10000;i++)&#123; //1.攒SQL ps.addBatch(); if (i % 500 == 0)&#123; //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; //4.统一提交 conn.commit(); mysql服务器默认关闭批处理，修改参数,写在配置文件url的后面 1?rewriteBetchedStatements&#x3D;true 不允许自动提交 1.5 事务 当一个事务中执行多个操作时，要么所有的事物==都被提交==，要么放弃所有修改，==整个事务回滚==到最初的状态 数据一旦提交就不可回滚 当一个连接被创建时，默认情况下是自动提交事务 关闭数据库连接，数据就会自动提交 DDL操作一旦执行，都会自动提交，set autocommit = false对DDL不起作用 DML默认情况下，一旦执行，就会自动提交，可以通过 set autocommit = false取消自动提交 使用后需要恢复自动提交状态 1.5.1 考虑事务通用的增删改12345678910111213141516171819202122232425262728293031323334353637383940//模拟转账 public void testWithTx() &#123; Connection connection = null; try &#123; connection = JDBC.getConnection1(); System.out.println(connection.getAutoCommit()); //1.取消数据自动提交 connection.setAutoCommit(false); //操作一 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(connection,sql1,\"AA\"); //模拟网络异常// System.out.println(10/0); //操作二 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(connection,sql2,\"BB\"); //2.提交数据 connection.commit(); System.out.println(\"转账成功\"); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //3.回滚数据 connection.rollback(); System.out.println(\"转账失败\"); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; try &#123; //恢复自动提交状态 connection.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBC.closeResource1(connection,null,null); &#125; &#125; 123456789101112131415161718192021222324public int update(Connection connection,String sql, Object ...args) &#123;// Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库// connection = JDBC.getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 JDBC.closeResource1(null,preparedStatement,null); &#125; return 0; &#125; 1.5.2 事务的ACID属性 原子性 一致性 隔离性 持久性 1.5.3 数据库的并发 脏读 不可重复读 幻读 1.5.4 四种隔离级别 READ UNCOMMITTED (读未提交数据) READ COMMITED (读已提交数据) REPEATABLE READ (可重复读) SERIALIZABLE (序列化) 1.6 升级操作123public class CustomerImpl extends BaseDAO&lt;Customer&gt; implements CustomerDAO&#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public abstract class BaseDAO&lt;T&gt; &#123; private Class&lt;T&gt; clazz = null; &#123; //获取当前BaseDAO的子类继承的父类中的泛型 Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();//获取了父类的泛型参数 clazz = (Class&lt;T&gt;) actualTypeArguments[0]; &#125; //通用的增删改 public int update(Connection connection, String sql, Object ...args) &#123;// Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库// connection = JDBC.getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 JDBC.closeResource1(null,preparedStatement,null); &#125; return 0; &#125; //通用查询 public List&lt;T&gt; query2(Connection connection, String sql, Object...args) &#123;// Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123;// connection = JDBC.getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while (resultSet.next())&#123; T t = clazz.newInstance(); //处理结果集数据中的每一个列：给t对象指定的属性赋值 for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125;&#125;//通用特殊值查询 public &lt;E&gt; E getValue(Connection connection,String sql,Object...args) &#123; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt;args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; resultSet = preparedStatement.executeQuery(); if (resultSet.next())&#123; return (E) resultSet.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(null,preparedStatement,resultSet); &#125; return null; &#125; 1.7 数据库连接池1.7.1 德鲁伊（druid）123456789101112131415161718public class DruidTest &#123; private static DataSource source; static &#123; try &#123; Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid\"); pros.load(is); source = DruidDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws Exception &#123; Connection connection = source.getConnection(); System.out.println(connection); return connection; &#125;&#125; 1.8 DBUtils123456&lt;!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; 1.8.1 增删改123456789101112131415public void testQueryRunner() throws Exception &#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"insert into customers(id,name ,email ,birth)values(?,?,?,?)\"; int insertCount = runner.update(connection, sql, \"6\",\"蔡徐坤\", \"caixukun@qq.com\", \"1997-01-01\"); System.out.println(\"添加了\"+insertCount+\"条数据\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.2 查询（返回一条记录）123456789101112131415public void testQuery1() throws Exception&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select id,name,email from customers where id = ?\"; BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(connection, sql, handler, 5); System.out.println(customer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; BeanHandler：是ResultBeanHandler接口的实现类，用于封装表中的一条记录 1.8.3 查询（返回多条记录）123456789101112131415public void testQuery2() throws Exception&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select id,name,email from customers where id &lt; ?\"; BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(connection, sql, handler, 5); list.forEach(System.out::println); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.4 查询（特殊返回值）123456789101112131415public void testQuery3()&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select count(*) from customers\"; ScalarHandler handler = new ScalarHandler(); Long count = (Long) runner.query(connection, sql, handler); System.out.println(count); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.5 关闭资源12345public static void closeResources(Connection connection, Statement statement, ResultSet resultSet) &#123; DbUtils.closeQuietly(connection); DbUtils.closeQuietly(statement); DbUtils.closeQuietly(resultSet); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://gushihu1.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://gushihu1.com/tags/JDBC/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-29T13:54:25.396Z","updated":"2020-03-01T13:47:04.902Z","comments":true,"path":"2020/02/29/hello-world/","link":"","permalink":"http://gushihu1.com/2020/02/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}