{"meta":{"title":"孤失狐的博客","subtitle":"勿忘初心","description":"","author":"孤失狐","url":"http://gushihu1.com","root":"/"},"pages":[{"title":"","date":"2020-03-01T13:17:51.091Z","updated":"2020-03-01T13:17:51.091Z","comments":true,"path":"404.html","permalink":"http://gushihu1.com/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"react\":{\"opacity\":1},\"log\":false});"},{"title":"标签","date":"2020-03-02T11:04:09.000Z","updated":"2020-03-02T11:10:41.454Z","comments":true,"path":"tags/index.html","permalink":"http://gushihu1.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-02T11:05:29.000Z","updated":"2020-03-02T11:10:23.873Z","comments":true,"path":"categories/index.html","permalink":"http://gushihu1.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Git","slug":"Git","date":"2020-11-10T02:03:24.642Z","updated":"2020-03-23T07:52:11.888Z","comments":true,"path":"2020/11/10/Git/","link":"","permalink":"http://gushihu1.com/2020/11/10/Git/","excerpt":"","text":"Linux常用命令 cd：改变目录 pwd ：显示当前所在目录路径 ls：列出当前目录中的所有文件 touch：新建一个文件 rm：删除一个文件 mkdir：新建一个目录 rm -r：删除一个文件夹 mv：移动文件 reset：重新初始化终端、清屏 clean：清屏 history：查看命令历史 help：帮助 exit：退出 #：表示注释 Git 常用命令 查看状态：git status 初始化：git init 克隆：git clone 添加到暂存、跟踪：git add 全部：git add . 提交暂存区的内容：git commit git commit -m “消息内容” Git 忽略部分文件代码仓库的SSH公钥分支管理","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2020-11-10T02:03:24.601Z","updated":"2020-02-21T12:47:06.945Z","comments":true,"path":"2020/11/10/Spring/","link":"","permalink":"http://gushihu1.com/2020/11/10/Spring/","excerpt":"","text":"Spring工厂IOC依赖123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件applicationContext12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt; 启动工厂 工厂接口：ApplicationContext 实现类：ClassPathXmlApplicationContext 12345&lt;!-- 声明，哪些组件需要生产 --&gt; &lt;!-- 当spring启动时，读取该配置文件，创建对应的类的对象，并用id作标识 --&gt; &lt;bean id=\"userDAO04\" class=\"com.lmt.dao.UserDAOImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"userService04\" class=\"com.lmt.service.UserServiceImpl\"&gt;&lt;/bean&gt; 123456789101112/** * 工厂启动 */@Testpublic void factoryBoot()&#123; //启动工厂 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); //从工厂中获取 组件 UserDAO userDAO = (UserDAO) context.getBean(\"userDAO04\"); UserDAO userDAO2 = context.getBean(\"userDAO04\", UserDAO.class); userDAO.insertUser(new User());&#125; 组件的稳健度 解决强耦合配置文件 1234567891011&lt;bean id=\"userDAO04\" class=\"com.lmt.dao.UserDAOImpl\"&gt;&lt;/bean&gt; &lt;!-- Spring生产该对象 对象中有一个属性需要赋值 --&gt; &lt;bean id=\"userService04\" class=\"com.lmt.service.UserServiceImpl\"&gt; &lt;!-- 给属性 userDAO 赋值 值：id=“userDAO04”的组件 --&gt; &lt;property name=\"userDAO\" ref=\"userDAO04\"/&gt; &lt;/bean&gt; 实现类 12345678910111213141516171819public class UserServiceImpl implements UserService &#123;// private UserDAO userDAO = new UserDAOImpl(); //去掉强耦合，留下接口 private UserDAO userDAO; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; System.out.println(\"set DAO for Service\"); this.userDAO = userDAO; &#125; @Override public void insertUser(User user) &#123; System.out.println(\"insert user in Service\"); userDAO.insertUser(user); &#125;&#125; 主方法 123ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\");//根据配置文件路径获取一个工厂UserService userService04 = context.getBean(\"userService04\", UserService.class); userService04.insertUser(new User()); 结果 1234set DAO for Serviceinsert user in Servicecom.lmt.dao.UserDAOImpl@1e7c7811insert user in DAO 控制反转IOC 之前的自己创建的依赖对象，变为由工厂推送（即变主动为被动） 解决了具有依赖关系的组件之间的强耦合，使得项目形态更加稳健 依赖注入DI 全新的依赖满足方式，体现在编码中就是去哪新的赋值方式 -&gt; 在工厂中为属性推送值 IOC和DI IOC和DI是一码事 IOC是思想 DI是手段 DI的方式 set注入 构造注入（了解） 自动注入 set注入可以和构造注入一起使用 set注入 需要set方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class SetComponent &#123; //整形 private Integer id; //字符串 private String name; //布尔 private Boolean gender; //对象 private UserDAO userDAO; //集合 private List&lt;Object&gt; list04; // private Set&lt;String&gt; set04; //Map private Map&lt;String,Object&gt; map04; // private Properties props04; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Boolean getGender() &#123; return gender; &#125; public void setGender(Boolean gender) &#123; this.gender = gender; &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; public List&lt;Object&gt; getList04() &#123; return list04; &#125; public void setList04(List&lt;Object&gt; list04) &#123; this.list04 = list04; &#125; public Set&lt;String&gt; getSet04() &#123; return set04; &#125; public void setSet04(Set&lt;String&gt; set04) &#123; this.set04 = set04; &#125; public Map&lt;String, Object&gt; getMap04() &#123; return map04; &#125; public void setMap04(Map&lt;String, Object&gt; map04) &#123; this.map04 = map04; &#125; public Properties getProps04() &#123; return props04; &#125; public void setProps04(Properties props04) &#123; this.props04 = props04; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 注入测试 --&gt; &lt;bean id=\"di04\" class=\"com.lmt.di.SetComponent\"&gt; &lt;!-- 简单类型 基本类型+String --&gt; &lt;property name=\"id\" value=\"4\"/&gt; &lt;property name=\"name\" value=\"zhangsan\"/&gt; &lt;property name=\"gender\" value=\"true\"/&gt; &lt;!--引用类型--&gt; &lt;property name=\"userDAO\" ref=\"userDAO04_2\"/&gt; &lt;!--List--&gt; &lt;property name=\"list04\"&gt; &lt;list&gt; &lt;value&gt;gp04&lt;/value&gt; &lt;ref bean=\"userDAO04_2\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Set --&gt; &lt;property name=\"set04\"&gt; &lt;set&gt; &lt;value&gt;zhangsan&lt;/value&gt; &lt;value&gt;zhangsan&lt;/value&gt; &lt;value&gt;zhangsan&lt;/value&gt; &lt;value&gt;lisi&lt;/value&gt; &lt;value&gt;lisi&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=\"map04\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"suxing\"/&gt; &lt;entry key=\"ud04\" value-ref=\"userDAO04_2\"/&gt; &lt;!--&lt;entry key=\"list04\"&gt; &lt;list&gt;&lt;/list&gt; &lt;/entry&gt;--&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=\"props04\"&gt; &lt;props&gt; &lt;prop key=\"url\"&gt;jdbc:mysql//xxxxx&lt;/prop&gt; &lt;prop key=\"driver\"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 构造注入 根据传入参数顺序选择构造器 123456@Test public void testDi2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); ConsComponent di04 = context.getBean(\"consDI04\", ConsComponent.class); System.out.println(\"=================================\"); &#125; 123456789101112131415161718192021222324252627public class ConsComponent &#123; private Integer id; private String name; private Boolean gender; public ConsComponent() &#123; &#125; public ConsComponent(Integer id, String name, Boolean gender) &#123; System.out.println(\"构造1\"); this.id = id; this.name = name; this.gender = gender; &#125; public ConsComponent(Integer id, String name) &#123; System.out.println(\"构造2\"); this.id = id; this.name = name; &#125; public ConsComponent(Boolean gender,Integer id, String name ) &#123; System.out.println(\"构造3\"); this.id = id; this.name = name; this.gender = gender; &#125;&#125; 12345&lt;bean id=\"consDI04\" class=\"com.lmt.di.ConsComponent\"&gt; &lt;constructor-arg index=\"0\" type=\"java.lang.Boolean\" value=\"true\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" type=\"java.lang.Integer\" value=\"4\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"2\" type=\"java.lang.String\" value=\"wanger\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 结果 12构造3&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 自动注入 掌握 byType 和 byType 概念区别即可 123456&lt;!--自动注入 autowire = 自动装载 byType = 将工厂中和属性类型一致的组件，赋值给对应属性 byType = 将工厂中和属性名称一致的组件，组织给对应属性 --&gt; &lt;bean id=\"autoDI04\" class=\"com.lmt.di.AutoComponent\" autowire=\"byName\"&gt;&lt;/bean&gt; 123456@Test public void testDi3()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); // AutoComponent di04 = context.getBean(\"autoDI04\", AutoComponent.class); System.out.println(\"=================================\"); &#125; Bean细节Bean创建细节 反射，加载类对象，默认调用无参构造，创建对象 123456&lt;bean class&#x3D;&quot;xx.xx.xxx.XXX&quot; id&#x3D;&quot;xxx&quot;&gt;&#x2F;&#x2F;反射String classpath &#x3D; &quot;com.lmt.domain.User&quot;Class user &#x3D; Class.forName(classpath);Constructor constructor &#x3D; user .getConstructor();User o &#x3D; (User)constructor.newInstance(); Bean创建模式 singleton：单例 -&gt; ==默认== 在同一个spring工厂中，一个bean只会创建一次对象 多次getBean，或多次注入使用的是同一个对象 随工厂创建而创建，随工厂关闭而销毁 prototype：多例（原型） 每次getBean（），或者注入都会重新创建对象 不随工厂创建而创建，不随工厂关闭而销毁 被用到时才会创建对象 对象的状态：对象的成员变量值 即对象的状态 无状态：不同的用户，不同的请求，对象的属性值不会发生改变 有状态：不同的用户，不同的请求，对象的属性值会发生改变 有状态对象：多例模式 无状态对象：单例模式 工厂Bean（重点） FactoryBean：生产某一类对象 在工厂中有些bean，无法通过简单的生产 比如：Connection，SqlSessionFactory FactoryBean：spring工厂中一种特殊的bean，可以生产对象，spring工厂中的小作坊 FactoryBean123456&lt;!--工厂Bean 细节： 1.&gt; FactoryBean的生命周期和常规的Bean没区别 2.&gt; 当用户通过getBean获取一个FactoryBean时，返回的并不是工厂Bean本身，而是其创建生产的对象 3.&gt; 如果想获得工厂bean本身，需要\"&amp;beanID\"==\"&amp;mySqlSessionFactory\" --&gt; &lt;bean id=\"mySqlSessionFactory\" class=\"com.lmt.factorybean.MySqlSessionFactoryBean\"&gt;&lt;/bean&gt; 1234567891011121314151617181920212223/** * 工厂Bean，生产SqlSessionFactory */public class MySqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt; &#123; //主体逻辑，完成某种复杂对象的生产 @Override public SqlSessionFactory getObject() throws Exception &#123; //构建过程 Reader reader = Resources.getResourceAsReader(\"configuration\");//配置文件 return new SqlSessionFactoryBuilder().build(reader); &#125; //返回 某种复杂对象的 类对象 @Override public Class&lt;?&gt; getObjectType() &#123; return SqlSessionFactory.class; &#125; //控制复杂对象的创建模式 @Override public boolean isSingleton() &#123; return false; &#125;&#125; 静态工厂12&lt;!--工厂Bean：静态工厂--&gt; &lt;bean id=\"mySqlSessionFactory2\" class=\"com.lmt.factorybean.MySqlSessionFactoryBean2\" factory-method=\"buildSqlSessionFactory\"&gt;&lt;/bean&gt; 123456789/** * 静态工厂 */public class MySqlSessionFactoryBean2 &#123; public static SqlSessionFactory buildSqlSessionFactory()throws Exception&#123; Reader reader = Resources.getResourceAsReader(\"configuration\"); return new SqlSessionFactoryBuilder().build(reader); &#125;&#125; Lombok1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1234567@Data //get set toString equals canEqual hashCode 方法@AllArgsConstructor //全参构造@NoArgsConstructor //无参构造public class User &#123; private Integer id; private String name;&#125; 修改骨架 找到自己的本地仓库 - org - apache - maven - apchetypes 已经用过的骨架全在这个文件夹下 找到里面的 jar包，不要解压，直接打开 找到里面的 pom.xml 即可修改骨架 保存修改即可 AOP 面向切面编程，一种编程思想 切面：Aspect，由切入点和额外功能（增强）组成 提供了新的编程角度，不再只是考虑类/对象，而可以考虑切面。切面和目标形成代理，解决项目业务中额外功能冗余的问题。 依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 代理1234public interface UserService &#123; public Integer insertUser(User user); public User queryOne(Integer id);&#125; 123456789101112131415public class UserServiceImpl implements UserService &#123; @Override public Integer insertUser(User user) &#123; // System.out.println(\"额外功能\"); System.out.println(\"核心功能 in insert User\"); return 4; &#125; @Override public User queryOne(Integer id) &#123; // System.out.println(\"额外功能\"); System.out.println(\"核心功能 in query User\"); return new User(); &#125;&#125; 12345678910111213141516171819/** * 代替UserServiceImpl 打理 额外功能 * 静态代理类 * 1.要和目标保持功能一致：和目标保持同一套接口 * 2.组成：目标+额外功能 */public class UserServiceProxy implements UserService&#123; //原始业务 private UserService userService = new UserServiceImpl(); public Integer insertUser(User user)&#123; System.out.println(\"额外功能\"); return userService.insertUser(user); &#125; public User queryOne(Integer id)&#123; System.out.println(\"额外功能\"); return userService.queryOne(id); &#125;&#125; 动态代理 jdk代理：通过和目标实现相同的接口保证功能一致 cglib代理：通过继承目标保证功能一致 123456789101112131415161718192021&lt;!--目标--&gt; &lt;bean id=\"userService\" class=\"com.lmt.service.UserServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"userService2\" class=\"com.lmt.service.UserServiceImpl2\"&gt;&lt;/bean&gt; &lt;!--额外功能：Advice--&gt; &lt;bean id=\"before04\" class=\"com.lmt.advice.MyBeforeAdvice\"&gt;&lt;/bean&gt; &lt;!--编制 通过目标的信息，额外功能的信息，组建一个新的类：Proxy --&gt; &lt;aop:config&gt; &lt;!-- 切入点：目标中方法 execution表达式 execution(修饰符 返回值 包.类.方法名（参数表）) execution( * com.lmt.service.*.*(..)) --&gt; &lt;aop:pointcut id=\"pc04\" expression=\"execution( * com.lmt.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:pointcut id=\"pc05\" expression=\"execution( * com.lmt.service.UserServiceImpl.queryOne(..))\"/&gt; &lt;aop:pointcut id=\"pc06\" expression=\"execution( * com.lmt.service.UserServiceImpl2.*(..))\"/&gt; &lt;!--将某个额外功能，编制到某些切入点中--&gt; &lt;aop:advisor advice-ref=\"before04\" pointcut-ref=\"pc05\"/&gt; &lt;aop:advisor advice-ref=\"before04\" pointcut-ref=\"pc06\"/&gt; &lt;/aop:config&gt; 12345678910@Test public void shouldAnswerWithTrue() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext\"); //获取代理对象，通过目标BeanID，即可获得 UserService userServiceProxy = (UserService) context.getBean(\"userService2\"); userServiceProxy.queryOne(1); System.out.println(\"===============\"); userServiceProxy.insertUser(new User()); &#125; 123456789101112131415public class UserServiceImpl2 implements UserService &#123; @Override public Integer insertUser(User user) &#123; // System.out.println(\"额外功能\"); System.out.println(\"核心功能 in insert User222222\"); return 4; &#125; @Override public User queryOne(Integer id) &#123; // System.out.println(\"额外功能\"); System.out.println(\"核心功能 in query User222222222\"); return new User(); &#125;&#125; 前置额外功能12345678910111213141516/** * 前置额外功能 */public class MyBeforeAdvice implements MethodBeforeAdvice &#123; /** * 主体逻辑，在核心功能之前执行 * @param method 当前执行的方法对象 * @param objects 方法的参数 * @param o 目标对象 * @throws Throwable */ @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(\"Before~~~\"); &#125;&#125; 结果 12345Before~~~核心功能 in query User222222222&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Before~~~核心功能 in insert User222222 后置额外功能123456789101112131415public class MyAfterAdvice implements AfterReturningAdvice &#123; /** * 在核心功能返回之后执行 * @param o 核心功能的返回值 * @param method 方法对象 * @param objects 方法的参数表 * @param o1 目标对象 * @throws Throwable */ @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(\"After~~~\"); &#125;&#125; 结果 12345核心功能 in query User222222222After~~~&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;核心功能 in insert User222222After~~~ 环绕额外功能1234567891011121314151617181920/** * 环绕额外功能 */public class MyMethodInterceptor implements MethodInterceptor &#123; /** * * @param methodInvocation * @return * @throws Throwable */ @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println(\"环绕前\"); //接受业务执行结果 Object ret = methodInvocation.proceed();//执行目标功能 核心功能 System.out.println(\"环绕后\"); //业务结果 向上返回 return ret; &#125;&#125; 结果 1234567环绕前核心功能 in query User222222222环绕后&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;环绕前核心功能 in insert User222222环绕后 一起用顺序 前置 环绕前 核心功能 环绕后 后置 建议：需要哪个写哪个，不要其他的代替 ​ 如：用环绕代替前，用前后代替环绕 异常时额外功能（了解）123456@Override public User queryOne(Integer id) &#123; // System.out.println(\"额外功能\"); System.out.println(\"核心功能 in query User222222222\"); int a= 10/0; return new User(); 1234567891011/** * 异常时额外功能 */public class MyThrows implements ThrowsAdvice &#123; //当核心功能异常时执行,ex = 异常对象 public void afterThrowing(Exception ex)&#123; System.out.println(\"出现异常啦~~~~~~~\"); System.out.println(ex.getMessage()); &#125;&#125; 结果 1234环绕前核心功能 in query User222222222出现异常啦~~~~~~~&#x2F; by zero 最终额外功能（了解）切入点表达式execution1execution(修饰符 返回值 包.类.方法名（参数表）) * com.service.UserServiceImpl.queryUser(..) 1234567891011121314 修饰符：任意 返回值：任意 包：com.service 类：UserServiceImpl 方法：queryUser 参数表：任意2. * com.service.UserServiceImpl.*(..) 1234567891011121314 修饰符：任意 返回值：任意 包：com.service 类：UserServiceImpl 方法：所有，任意 参数表：任意3. * com..UserServiceImpl.*(..) 1234567891011121314 修饰符：任意 返回值：任意 包：com包，及其子包 类：UserServiceImpl 方法：所有，任意 参数表：任意4. * com.service.*.*(..) 1234567891011121314 修饰符：任意 返回值：任意 包：com.service包 类：所有，任意 方法：所有，任意 参数表：任意5. * *(..) 不建议 1234567891011121314 修饰符：任意 返回值：任意 包：任意 类：所有，任意 方法：所有，任意 参数表：任意6. * com.service.UserServiceImpl.query*(..) 批量切入技巧 123456789101112131415161718192021222324 修饰符：任意 返回值：任意 包：com.service 类：UserServiceImpl 方法：所有，任意 参数表：任意 **注意：尽量精确，避免不必要的切入**#### within&gt;描述 **包** 和 **类** ，**类** 中所有的方法都切入&#96;&#96;&#96;xmlwithin(com.service.UserServiceImpl) 类中所有的方法within(com..UserServiceImpl) com包和com子包下的类中的所有方法&lt;aop:pointcut id&#x3D;&quot;pc&quot; expression&#x3D;&quot;within(com..UserServiceImpl)&quot;&#x2F;&gt; args 描述 参数表 ，符合的方法都切入 123args(int,String,com.lmt.pojo.User) 参数表如此的方法 &lt;aop:pointcut id=\"pc07\" expression=\"args(int,String,com.lmt.pojo.User)\"/&gt; 联用 不同种类的表达式之间，可以使用逻辑运算： and or not 123&lt;aop:pointcut id=\"pc\" expression=\"within(com..UserServiceImpl) and args(int,String,com.lmt.pojo.User)\"/&gt;&lt;aop:pointcut id=\"pc\" expression=\"within(com..UserServiceImpl) and not args(int,String,com.lmt.pojo.User)\"/&gt;&lt;aop:pointcut id=\"pc\" expression=\"execution( * com.lmt.service.UserServiceImpl2.*(..)) and args(int,String,com.lmt.pojo.User)\"/&gt; AOP细节周期 构造 - &gt; 注入属性 满足依赖 - &gt; 初始化 - &gt; 返回 - &gt; 销毁 完整周期 构造 - &gt; 注入属性 满足依赖 - &gt; 后置处理器前置过程 - &gt; 初始化 - &gt; 后置处理器后置过程 - &gt;返回 - &gt; 销毁 后处理器，对工厂中所有bean 声明周期进行干预 cglib选择12&lt;-- 强制使用cglib代理 --&gt;&lt;aop:config proxy-target-class=\"true\"&gt; 切入顺序当一个对象，需要两个或这多个前置时 默认按照配置文件的声明顺序，默认先执行 before01 12&lt;aop:advisor advice-ref=\"before01\" pointcut-ref=\"pc04\"/&gt; &lt;aop:advisor advice-ref=\"before02\" pointcut-ref=\"pc04\"/&gt; 可以用 order 属性表明顺序,此时 before02 先执行，order 越小，越优先 12&lt;aop:advisor advice-ref=\"before01\" pointcut-ref=\"pc04\" order=\"2\"/&gt; &lt;aop:advisor advice-ref=\"before02\" pointcut-ref=\"pc04\" order=\"1\"/&gt; Spring-Mybatis整合DAO依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring 组件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--DAO--&gt; &lt;!--连接池--&gt; &lt;bean class=\"org.apache.commons.dbcp.BasicDataSource\" id=\"dbcp04\" destroy-method=\"close\"&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"admin\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost/testmybatis?serverTimezone=UTC\"/&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;/bean&gt; &lt;!--SqlSessionFactory 配置：1.连接池 2.mapper文件信息 3.别名-可选 4.插件-可选 --&gt; &lt;bean id=\"sqlSessionFactory04\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--连接池--&gt; &lt;property name=\"dataSource\" ref=\"dbcp04\"/&gt; &lt;!--mapper文件 如果和dao接口文件在同包且同名,则如下注入可以省略 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/lmt/dao/*.xml\"/&gt; &lt;!--别名--&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.lmt.domain\"/&gt; &lt;!--插件--&gt; &lt;!--&lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;--&gt; &lt;/bean&gt; &lt;!--扫描所有mapper，为每个dao定制实现类 DAO实现的对象会纳入工厂，并且beanID=DAO的首字母小写接口类名=“studentDAO” 1.DAO接口 2.DAO映射文件 3.SqlSession --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!--如果当前工厂中，只有一个SqlSessionFactory,则此项注入可以省略--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory04\"/&gt; &lt;!--DAO接口位置--&gt; &lt;property name=\"basePackage\" value=\"com.lmt.dao\"/&gt; &lt;/bean&gt; service12345678910111213141516171819202122232425262728293031323334353637&lt;!--Service--&gt; &lt;bean id=\"studentService04\" class=\"com.lmt.service.StudentServiceImpl\"&gt; &lt;property name=\"studentDao\" ref=\"studentDao\"/&gt; &lt;/bean&gt; &lt;!--事务处理--&gt; &lt;!--事务管理器--&gt; &lt;bean id=\"tx\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dbcp04\"/&gt; &lt;/bean&gt; &lt;!--事务管理的 额外功能 事务管理的实现由“tx”提供 --&gt; &lt;tx:advice id=\"txManager\" transaction-manager=\"tx\"&gt; &lt;tx:attributes&gt; &lt;!--name为可能切入事务的方法--&gt; &lt;tx:method name=\"queryStudent\"/&gt; &lt;!-- isolation:隔离级别 propagation:传播性 support:如果已有事务，则融入这个事务，如果没有事务，则以非事务环境运行 required:如果已有事务，则融入这个事务，如果没有事务，开启自己的事务（默认值） read-only:读写性 true:只读事务，事务中只出现查询行为 false:读写事务，事务中可以出现curd行为（默认值） rollback-for:回滚 --&gt; &lt;tx:method name=\"queryStudentById\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" /&gt; &lt;!-- * 剩余所有--&gt; &lt;tx:method name=\"*\" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--编织--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pc_tx\" expression=\"execution(* com..StudentServiceImpl.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txManager\" pointcut-ref=\"pc_tx\"/&gt; &lt;/aop:config&gt; 更新丢失悲观锁 for update 乐观锁 version 版本号 连接池12345&lt;bean id=\"druid04\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"admin\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost/testmybatis?serverTimezone=UTC\"/&gt; &lt;/bean&gt; 注解注解的扫描1234&lt;!--配置注解扫描，让spring去发现注解，进而实现对应的功能--&gt; &lt;context:component-scan base-package=\"com.lmt\"/&gt; &lt;!--支持@Transactional实现事务--&gt; &lt;tx:annotation-driven transaction-manager=\"tx\"/&gt; 部分bean可以省略 @Service 业务类专用 相当于&lt;bean class=”当前类” id=”首字母小写类名” 也可以自定义id，@Service(“id名”) @Repository dao实现类专用 @Controller web层专用 @Component 通用 @Scope 用户控制bean的创建模式 更便捷的注入方式 基于注解不需要get和set方法 @Autowired 基于类型自动注入 @Resource 基于名称自动注入 工厂配置中的&lt;tx:advice…和&lt;aop:config…可以省略 @Transactional 用于为业务中切入事务 当前类中的所有方法都切入事务 添加属性@Transactional (isolation = Isolation.DEFAULT,…) 如果方法中加入注解，则按方法中的注解属性 @AspectJ配置文件1&lt;aop:aspectj-autoproxy/&gt; 注解 @Aspect 声明当前组件为一个切面组件 @Component 声明当前组件 @Pointcut 定义切入点 @Before 定义额外功能 @Order 定义先后顺序 123456789101112131415161718192021222324252627282930313233343536373839@Aspect //声明当前组件为一个切面@Component //声明当前组件public class MyAspect &#123; //定义切入点 @Pointcut(\"execution(* com.lmt..StudentServiceImpl.*(..))\") public void pc04() &#123; &#125; //定义额外功能 //前 @Before(\"pc04()\") public void myBefore() &#123; System.out.println(\"前置就是这个了\"); &#125; //后可以接受返回值 @AfterReturning(value = \"pc04()\",returning = \"ret\") public void myAfter(Object ret) &#123; System.out.println(\"后置就是这个了\"); System.out.println(\"这是后的返回值：\"+ret); System.out.println(\"这也是后\"); &#125; //环绕 @Around(\"pc04()\") public Object myAround(ProceedingJoinPoint p) throws Throwable&#123; System.out.println(\"环绕前\"); Object ret = p.proceed();//调用核心逻辑 System.out.println(\"环绕后\"); return ret; &#125; //异常时 @AfterThrowing(value = \"pc04()\",throwing = \"ex\") public void myThrows(Exception ex)&#123; System.out.println(\"出错啦\"+ex.getMessage()); &#125;&#125; 导入外部参数文件12&lt;!--导入外部参数文件--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; 与web集成servlet相关依赖12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; web.xml配置文件12345678910111213&lt;!-- 在项目启动时，随之启动spring的工厂 依赖：需要spring的配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--声明spring的配置文件位置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;","categories":[],"tags":[]},{"title":"opencv","slug":"opencv","date":"2020-11-10T02:03:24.601Z","updated":"2020-01-22T09:47:02.609Z","comments":true,"path":"2020/11/10/opencv/","link":"","permalink":"http://gushihu1.com/2020/11/10/opencv/","excerpt":"","text":"1 opencv1.1 第一章1.1.1 加载/修改/保存 加载图像（用cv::imread） 修改图像（cv::cvtColor） 保存图像（cv::imwrite） 1.1.1.1 加载图像 imread功能是加载图像文件成为一个Mat对象，其中第一个参数表示图像文件名称 第二个参数，表示加载的图像是什么类型，支持常见的三个参数值 IMREAD_UNCHANGED(&lt;0)表示加载原图，不做任何改变 IMREAD_GRAYSCALE(0)表示把原图作为灰度图加载进来 IMREAD_COLOR(&gt;0)表示把原图作为RGB图像加载进来","categories":[],"tags":[]},{"title":"Mybatis","slug":"Mybatis","date":"2020-11-10T02:03:24.559Z","updated":"2020-02-29T13:24:00.774Z","comments":true,"path":"2020/11/10/Mybatis/","link":"","permalink":"http://gushihu1.com/2020/11/10/Mybatis/","excerpt":"","text":"Mybatisjar包依赖1234567891011121314151617181920&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 配置mapper文件夹为配置文件夹1234567891011121314&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/Java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.* &lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; 配置文件主配置文件 只有一个 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper配置文件 几个表就有几份 用来写SQL语句 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/lmt/mapper/StudentMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j配置信息1234567log4j.rootLogger=DEBUG,stdoutlog4j.logger.org.mybatis.example.BlogMapper=TRACElog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c] [%p] - %m%n 连接创建12345678String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); //SqlSessionFactory对象的作用就是为我们创建一个SqlSession对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);//我们未来所有的操作，使用的都是SqlSession对象session来完成 //例如增删改查，处理事务等等，都是统一使用session对象来完成 SqlSession session = sqlSessionFactory.openSession(); 关闭1session.close(); 操作查单条12345678/* * 需求：根据id查单条 * 如果取得的是单条纪录，我们调用selectOne方法 * 参数1：根据 命名空间名.SQLID 的形式找到我们需要使用的SQL语句 * 参数2：我们要为SQL语句中传递的参数 * */ Student student = session.selectOne(\"test1.getById\", \"A0001\"); System.out.println(student); 123456&lt;!--SQL语句必须写在相对应的标签中 &lt;insert&gt; &lt;update&gt; &lt;delete&gt; &lt;select&gt; --&gt; &lt;select id=\"getById\" parameterType=\"java.lang.String\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_stident where id=#&#123;id&#125; &lt;/select&gt; 查所有12345//查询学生信息表中所有的记录 List&lt;Student&gt; studentList = session.selectList(\"test1.getAll\"); for (Student student:studentList)&#123; System.out.println(student); &#125; 123456&lt;!-- 如果返回的是多条记录，那么resultType返回值类型，应该写集合的泛型 --&gt; &lt;select id=\"getAll\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student &lt;/select&gt; 添加12345678910/* * Mybatis默认情况下是手动提交事务 * */ //添加操作 Student student = new Student(); student.setId(\"A0006\"); student.setName(\"cxk\"); student.setAge(23); session.insert(\"test1.save\", student); session.commit(); 123&lt;insert id=\"save\"&gt; insert into tbl_student (id,name,age) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; 修改1234567//修改操作Student student = new Student();student.setId(\"A0006\");student.setName(\"cxk\");student.setAge(24);session.update(\"test1.update\", student);session.commit(); 123&lt;update id=\"update\"&gt; update tbl_student set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125; &lt;/update&gt; 删除123//删除操作 session.delete(\"test1.delete\", \"A0006\"); session.commit(); 123&lt;delete id=\"delete\"&gt; delete from tbl_student where id=#&#123;id&#125; &lt;/delete&gt; Mybatis与JDBC 获取连接 得到statement 处理rs 关闭资源非常繁琐 解决：使用SqlSession解决一切 将SQL语句写死到Java代码中，如果修改SQL语句，必须要修改Java代码，需要重新编译。程序可维护性不高 解决：将SQL语句配置在Mapper.xml文件中与Java代码分离 向PreparedStatement对占位符的位置设置参数时，非常繁琐 解决：Mybatis自动将Java对象映射至SQL语句，通过statement中的paramentType定义输入参数的类型 解析结果集时需要把字段的值设置到相应的实体类属性名中 解决：Mybatis自动将SQL执行结果映射至Java对象，通过statement中的resultType定义输出结果的类型 Util工具类1234567891011121314151617181920212223242526272829303132333435363738public class SqlSessionUtil &#123; //类私有化，不能创建 private SqlSessionUtil()&#123;&#125; private static SqlSessionFactory sqlSessionFactory; static &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; private static ThreadLocal&lt;SqlSession&gt; t = new ThreadLocal&lt;SqlSession&gt;(); //取得SqlSession对象 public static SqlSession getSession()&#123; SqlSession session = t.get(); if (session==null)&#123; session = sqlSessionFactory.openSession(); t.set(session); &#125; return session; &#125; //关闭SqlSession对象 public static void myClose(SqlSession session)&#123; if (session != null)&#123; session.close(); //这句必须加，非常容易忘 //清空 t.remove(); &#125; &#125;&#125; 业务层动态代理类1234567891011121314151617181920212223242526272829303132public class TransactionInvocationHandler implements InvocationHandler &#123; private Object target; public TransactionInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; SqlSession session = null; Object obj = null; try &#123; session = SqlSessionUtil.getSession(); //处理业务逻辑 obj = method.invoke(target, args); //处理业务逻辑完毕后，提交事务 session.commit(); &#125; catch (Exception e) &#123; session.rollback(); e.printStackTrace(); &#125; finally &#123; SqlSessionUtil.myClose(session); &#125; return obj; &#125; public Object getProxy()&#123; //取得代理类对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125;&#125; 12345public class ServiceFactory &#123; public static Object getService(Object service)&#123; return new TransactionInvocationHandler(service).getProxy(); &#125;&#125; 通过业务层实现dao层 1234567891011121314public class StudentDaoImpl implements StudentDao &#123; @Override public Student getById(String id) &#123; SqlSession session = SqlSessionUtil.getSession(); Student student = session.selectOne(\"test1.getById\",id); return student; &#125; @Override public void save(Student student) &#123; SqlSession session = SqlSessionUtil.getSession(); session.insert(\"test1.save\",student); &#125;&#125; service层 12345678910111213public class StudentServiceImpl implements StudentService &#123; private StudentDao studentDao = new StudentDaoImpl(); @Override public Student getById(String id) &#123; Student student = studentDao.getById(id); return student; &#125; @Override public void save(Student student) &#123; studentDao.save(student); &#125;&#125; 主方法调用 1234567891011@Test public void test1() throws IOException &#123; // StudentService studentService = new StudentServiceImpl();不行 StudentService studentService = (StudentService) ServiceFactory.getService(new StudentServiceImpl()); Student student = new Student(); student.setId(\"A0006\"); student.setName(\"cxk\"); student.setAge(23); studentService.save(student); &#125; 123//测试根据id查单条操作 Student student = studentService.getById(\"A0001\"); System.out.println(student); Mybatis对dao层动态代理的支持 我们以前用过动态代理，我们是在业务层使用的，在业务层使用动态代理是为了实现事务管理。 业务层的动态代理是我们手写的 业务层之所以要使用动态代理，是因为业务层本身就是用来处理业务逻辑的，事务相关的代码不方便放在业务层处理，所以我们想到使用代理类帮业务层去处理。 现在我们要在dao层也要加入动态代理。dao层之所以创建代理类，是因为写dao层本身就是一种不方便。在结合了mybatis的动态代理机制后，以后的实际项目开发，dao层的impl就不写了。Mybatis的动态代理不用我们自己手写，在mybatis中已经集成好的一种机制，我们直接拿来使用就可以了。 规定 映射文件名必须和dao接口名在必须相同 映射文件和接口必须在同一个包下 映射文件namespace必须为接口的全路径 接口的方法名必须和映射文件的id相同 对于查询来说，映射文件的传递类型和返回值类型必须和方法的保持一致 12345678910&lt;mapper namespace=\"com.lmt.dao.StudentDao\"&gt; &lt;select id=\"getById\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=\"save\"&gt; insert into tbl_student(id,name,age)values (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 123456public interface StudentDao &#123; public Student getById(String id); public void save(Student student);&#125; 对于业务层创建实现类方法为 1private StudentDao studentDao = SqlSessionUtil.getSession().getMapper(StudentDao.class); 增删改查查询所有主方法 123456//查询所有记录 StudentService studentService = (StudentService) ServiceFactory.getService(new StudentServiceImpl()); List&lt;Student&gt; studentList = studentService.getAll(); for (Student s:studentList)&#123; System.out.println(s); &#125; dao service 接口添加对应方法 serviceimpl实现类 12345@Override public List&lt;Student&gt; getAll() &#123; List&lt;Student&gt; studentList = studentDao.getAll(); return studentList; &#125; dao映射文件 123&lt;select id=\"getAll\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student &lt;/select&gt; 配置文件配置主配置文件1234url=jdbc:mysql://localhost/testmybatis?serverTimezone=UTCusername=rootpassword=admindriverClassName=com.mysql.cj.jdbc.Driver 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;!--可以搭建环境，通过default进行选择--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/lmt/dao/StudentDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--1--&gt;&lt;settings&gt;&lt;!--没有必要--&gt;&lt;!--2--&gt;&lt;typeAliases&gt; &lt;!-- 为指定的类分别起别名 type：要为哪个类起别名，填写全名 alias：别名的名字 --&gt; &lt;typeAlias type=\"com.lmt.domain.Student\" alias=\"\"/&gt; &lt;!-- 为package标签批量起别名 别名是MyBatis默认为我们取好的，命名不是由我们自己决定，别名为类名（类名的字母不区分大小写）虽然不区分大小写，但是我们还是要按照约定俗称的规则写，写类名或者首字母小写 name：指定一个包结构，表示在该包下，所有的domain自动起好了别名 --&gt; &lt;package name=\"com.lmt.domain\"/&gt; &lt;!-- 一般使用批量起别名的方式 也有公司会摒弃使用起别名的机制，认为全路径可以增加可读性 --&gt;&lt;/typeAliases&gt;&lt;!--3--&gt;&lt;mappers&gt; &lt;!-- 使用resource属性，指定mapper映射文件 --&gt; &lt;mapper resource=\"com/lmt/dao/StudentDao.xml\"/&gt; &lt;!-- 使用class属性，找到dao层接口的全路径 --&gt; &lt;mapper class=\"com.lmt.dao.StudentDao\"/&gt; &lt;!-- 批量注册(一般使用) name属性：指向dao层的包，表示在该dao包下，所有的mapper映射文件自动注册 --&gt; &lt;package name=\"com.lmt.dao\"/&gt; &lt;/mappers&gt; 海量级别的数据，提高效率基础操作对于常用的查询条件的字段，设置索引 高级操作使用nosql数据库，redis 专业操作搜索引擎（Elasticsearch与Solr），特针对于电商行业 简单类型查询String123//1.测试：parameterType 使用简单数据类型 StringStudent student = studentDao.select1(\"A0001\");System.out.println(student); 123&lt;select id=\"select1\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where id=#&#123;id&#125; &lt;/select&gt; int12345//2.测试：使用简单数据类型 int List&lt;Student&gt; student = studentDao.select2(23); for (Student student1:student)&#123; System.out.println(student1); &#125; 123&lt;select id=\"select2\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where age=#&#123;age&#125; &lt;/select&gt; 引用类型和集合类型 在实际项目的开发中，使用domain和map都可以为SQL语句同时传递多个参数 一般情况下，我们使用domain就行了 当domain不符合需求的情况下，我们一定要考虑使用map来传值 domain1234567891011//3.测试：使用domain为参数 /* 查询出姓名为wyf,年龄为23岁的学员信息 绝对不可以为SQL语句传递多个参数,如 select（\"wyf\",23） 如果我们要为SQL语句传递多个参数，我们应该将这多个参数封装到一个domain对象中，或者打包到一个map集合中*/ Student student = new Student(); student.setName(\"wyf\"); student.setAge(23); List&lt;Student&gt; studentList = studentDao.select3(student); for (Student student1:studentList)&#123; System.out.println(student1); &#125; 1234567&lt;!-- #&#123;&#125;中的属性名必须是domain类的属性名--&gt;&lt;select id=\"select3\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where name=#&#123;name&#125; and name=#&#123;name&#125; &lt;/select&gt; map12345678//4.测试：使用map为参数 Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"name\",\"wyf\"); map.put(\"age\", 23); List&lt;Student&gt; studentList = studentDao.select4(map); for (Student student1:studentList)&#123; System.out.println(student1); &#125; 123&lt;select id=\"select4\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where name=#&#123;name&#125; and name=#&#123;name&#125; &lt;/select&gt; #{}与${} #{}：表示占位符，可以有效防止SQL注入。使用其设置参数无需考虑参数的类型，只能占值的位置 ${}：表示拼接符，无法防止SQL注入。使用其设置参数必须考虑参数的类型 传递简单参数类型 如果获取简单类型参数，#{}中可以使用value或其他名称 如果获取简单参数类型，${}中只能使用value 在没有特殊要求的情况下，通常使用#{}占位符 在某些情况下必须使用${} 如：需要动态拼接表名 1Select * from $&#123;tablename&#125; 如：动态【拼接排序字段 1select * from tablename order by $&#123;username&#125; desc like模糊查询使用${}12345//5.测试：like模糊查询 方式1：使用 $&#123;&#125;了解 List&lt;Student&gt; studentList = studentDao.select5(\"z\"); for (Student student:studentList)&#123; System.out.println(student); &#125; 123&lt;select id=\"select5\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where name like '%$&#123;value&#125;%' &lt;/select&gt; 使用#{}12345//6.测试：like模糊查询 方式1：使用 $&#123;&#125;了解 List&lt;Student&gt; studentList = studentDao.select6(\"z\"); for (Student student:studentList)&#123; System.out.println(student); &#125; 1234567 &lt;!-- %空格#&#123;&#125;空格% 空格用于拼接，不能省略 --&gt;&lt;select id=\"select6\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where name like '%' #&#123;name&#125; '%' &lt;/select&gt; resultType设置返回值类型 返回简单类型 8+String 返回pojo domain 返回hashmap（注意返回值类型） 当查询字段名和pojo属性名不一致时的解决方案 返回String123//10.测试：返回String类型 String name = studentDao.select10(\"A0001\"); System.out.println(name); 123&lt;select id=\"select10\" resultType=\"String\"&gt; select name from tbl_student where id=#&#123;id&#125; &lt;/select&gt; 返回String类型集合123456//11.测试：返回String类型集合 //查询出所有学生的名字 List&lt;String&gt; nameList= studentDao.select11(); for (String name1:nameList)&#123; System.out.println(name1); &#125; 123&lt;select id=\"select11\" resultType=\"String\"&gt; select name from tbl_student &lt;/select&gt; 返回int类型1234//12.测试：返回int类型 //需求：查询表中一共有多少条信息 int count = studentDao.select12(); System.out.println(count); 123&lt;select id=\"select12\" resultType=\"int\"&gt; select count(*) from tbl_student &lt;/select&gt; 返回domain类型（略）返回map类型12345678910111213141516//14.测试：返回map类型 /* 系统会为我们自动创建出来一个list集合来保存这些map对象 */ List&lt;Map&lt;String,Object&gt;&gt; mapList= studentDao.select14(); //拆分list for (Map&lt;String,Object&gt; map:mapList)&#123; Set&lt;String&gt; set = map.keySet(); for (String key:set)&#123; // 获取key System.out.print(key+\"=\"); // 获取value System.out.println(map.get(key)); &#125; System.out.println(\"-----------------------------------\"); &#125; 123&lt;select id=\"select14\" resultType=\"map\"&gt; select * from tbl_student &lt;/select&gt; domain和map 对于SQL语句查询的结果，使用domain会更加方便 但是对于查询结果，很多情况，使用domain封装不了，所以我们会想到使用map来保存结果，如：根据年龄分组，查询出来每一个姓名对应的数量 对于字段名和domain属性类型不一致的处理起别名12345//15.测试：当数据库表字段名称和domain类属性名不一致时的处理 List&lt;Student&gt; studentList = studentDao.select15(); for (Student student:studentList)&#123; System.out.println(student); &#125; 1234&lt;!-- 起别名的方式--&gt;&lt;select id=\"select15\" resultType=\"com.lmt.domain.Student\"&gt; select id,fullname as name,age from tbl_student &lt;/select&gt; 使用resultMap12345//16.测试：当数据库表字段名称和domain类属性名不一致时的处理 List&lt;Student&gt; studentList = studentDao.select16(); for (Student student:studentList)&#123; System.out.println(student); &#125; 1234567891011121314151617181920212223242526&lt;!-- id:唯一标识 将来在使用到该resultMap标签时，使用id来找到这组标签 type：指定一个类型，与数据库表一一对应，建立起表字段和类属性的名字一一匹配的关系 --&gt; &lt;resultMap id=\"stuMap\" type=\"com.lmt.domain.Student\"&gt; &lt;!-- id:用来配置主键的对应关系 result：用来配置普通字段对应关系的 对于tbl_student表，表结果时一个id，两个普通字段 所以我们需要一个id标签，两个result标签 property属性：配置的是类中的属性名 column属性：配置的是表中的字段名 这样就能建立起类属性和表字段一一对应的关系了 --&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"fullname\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;/resultMap&gt; &lt;select id=\"select16\" resultMap=\"stuMap\"&gt; select * from tbl_student &lt;/select&gt; 动态SQLwhere + if12345678//17.测试：动态SQL where标签结合if标签 Student student = new Student(); student.setName(\"y\"); student.setAddress(\"a\"); List&lt;Student&gt; studentList1 = studentDao.select17(student); for (Student student1:studentList1)&#123; System.out.println(student1); &#125; 1234567891011121314151617181920&lt;select id=\"select17\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student &lt;!-- where标签： 当where标签在使用的时候，必须要搭配where标签对中的if标签来使用 通过if标签的判断，如果有查询条件，则展现where关键字，如果没有查询条件则不展现where关键字 where标签会自动的屏蔽掉第一个连接符 and/or --&gt; &lt;where&gt; &lt;!--name不等于空，同时name不等于空串--&gt; &lt;if test=\"name!=null and name!=''\"&gt; and name like '%' #&#123;name&#125; '%' &lt;/if&gt; &lt;if test=\"address!=null and address!=''\"&gt; and address like '%' #&#123;address&#125; '%' &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; foreach1234567// 18.测试；动态SQL foreach标签 //查询这三个学员的信息 String stringArr[] = &#123;\"A0001\",\"A0002\",\"A0003\"&#125;; List&lt;Student&gt; studentList = studentDao.select18(stringArr); for (Student student1:studentList)&#123; System.out.println(student1); &#125; 1234567891011121314151617&lt;select id=\"select18\" resultType=\"com.lmt.domain.Student\"&gt; select * from tbl_student where id in &lt;!-- foreach标签：用来遍历传递来的数组标签 collection：标识传递参数的类型 array：数组 list：集合 item：每一次遍历出来的元素，在使用该元素的时候，需要套用在#&#123;&#125;中 open：拼接循环的开始符号 close：拼接循环的结束符号 separator：元素与元素之间的分隔符 --&gt; &lt;foreach collection=\"array\" item=\"id\" open=\"(\" close=\")\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; SQL片段123//19.测试：sql片段 Student student = studentDao.select19(\"A0001\"); System.out.println(student); 1234567891011121314151617181920&lt;!-- 使用SQL标签制作SQL片段 SQL片段的作用是用来代替SQL语句中的代码 如果你的mapper映射文件中的SQL语句某些代码出现了大量的重复，我们可以使用SQL片段来代替他们 id：SQL片段的唯一标识，将来找到SQL片段使用id来进行定位 将来的实际项目开发中，使用SQL片段来替代重复率高，且复杂的子查询 如：嵌套查询 注意：对于SQL片段 在同一个mapper下，大量的出现重复的子查询的几率不高，所以一般情况下没有使用SQL片段的必要 在实际项目开发中，如果大量的使用SQL片段，会大大的降低SQL语句的可读性 在很多企业中，干脆不用--&gt;&lt;sql id=\"sql1\"&gt; select * from tbl_student&lt;/sql&gt;&lt;select id=\"select19\" resultType=\"com.lmt.domain.Student\"&gt; &lt;include refid=\"sql1\"/&gt; where id=#&#123;id&#125;&lt;/select&gt; 多表联查12345678910111213//20.测试：多表联查 //查询出学生姓名和班级 List&lt;Map&lt;String,Object&gt;&gt; mapListList = studentDao.select20(); for (Map&lt;String,Object&gt; map:mapListList)&#123; Set&lt;String&gt; set = map.keySet(); for (String key:set)&#123; // 获取key System.out.print(key+\"=\"); // 获取value System.out.println(map.get(key)); &#125; System.out.println(\"-------------------------\"); &#125; 123456&lt;select id=\"select20\" resultType=\"map\"&gt; select s.name as 学生,c.name as 班级 from tbl_student s join tbl_classroom c on s.classroomId=c.id &lt;/select&gt; 使用vo1234567891011121314151617181920212223242526//21.测试：多表联查 //查询出学生和班级所有信息，加VO（value Object） /* * 在实际项目开发中，如果需要为前端展现数据，使用一个domain类型不足以表现出来这些数据 * 这时我们可以考虑使用两种技术来实现 * 分别为： * 使用map * 使用vo * 例如我们现在的需求 * 查询出学生和班级所有信息 * 得到的结果 使用学生的domain或者班级的domain都不能都封装这些结果 * * 所以我们可以使用map去保存这些信息 * 同时我们也可以使用vo类来保存这些信息 * * vo值得是创建出来一个类，这个类中的属性是完全由我们自己去定义，属性会保存所有需要展现的信息 * 例如我们现在这个例子，我们可以使用vo来封装所有与学生和班级相关的信息 * * vo * student * classroom * */ List&lt;StudentAndClassroomVo&gt; studentAndClassroomVoList = studentDao.select21(); for (StudentAndClassroomVo studentAndClassroomVo:studentAndClassroomVoList)&#123; System.out.println(studentAndClassroomVo); &#125; 123456789101112&lt;select id=\"select21\" resultType=\"com.lmt.vo.StudentAndClassroomVo\"&gt; select s.id sid, s.name sname, s.age sage, s.address saddress, c.id cid, c.name cname from tbl_student s join tbl_classroom c on s.classroomId=c.id &lt;/select&gt; vo条件查询123456//22.测试：多表联查 //查询出带有字母z的学生和班级所有信息 List&lt;StudentAndClassroomVo&gt; studentAndClassroomVoList = studentDao.select22(\"z\"); for (StudentAndClassroomVo studentAndClassroomVo:studentAndClassroomVoList)&#123; System.out.println(studentAndClassroomVo); &#125; 123456789101112131415&lt;select id=\"select22\" resultType=\"com.lmt.vo.StudentAndClassroomVo\"&gt; select s.id sid, s.name sname, s.age sage, s.address saddress, c.id cid, c.name cname from tbl_student s join tbl_classroom c on s.classroomId=c.id where s.name like '%' #&#123;name&#125; '%' &lt;/select&gt; map 与 vo 如果前端的需求的重复率不高，那么我们选择使用map就可以了 如果前端对于该需求的重复率较高，那么我们就可以创建一个vo类使用 使用注解 注解在接口上实现 需要在核心配置文件中绑定接口 本质：反射机制实现 底层：动态代理","categories":[],"tags":[]},{"title":"IDEA使用技巧","slug":"IDEA使用技巧","date":"2020-11-10T02:03:24.512Z","updated":"2020-03-13T06:25:37.270Z","comments":true,"path":"2020/11/10/IDEA使用技巧/","link":"","permalink":"http://gushihu1.com/2020/11/10/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"IDEA使用技巧修改骨架 找到自己的本地仓库 - org - apache - maven - apchetypes 已经用过的骨架全在这个文件夹下 找到里面的 jar包，不要解压，直接打开 找到里面的 pom.xml 即可修改骨架 保存修改即可 提示大小写不敏感 在Settings - Editor - General - Code Completion 中 把最上面的 Match case 的勾点掉 单行注释缩进 Java 在Settings - Editor - Code Style - Java 页面 最后一列 Code Generation 中间位置，右侧Comment Code 去掉勾选 Line comment at first column XML 在Settings - Editor - Code Style - XML 页面 在靠后位置 Code Generation 列 去掉勾选 Line comment at first column 一些常用的插件 CodeGlance 代码地图，滚动条放大镜 Translation 翻译软件 Rainbow Brackets 多种颜色的括号 Grep Console 控制台输出信息颜色 Statistic 项目统计 Markdown Navigator RestfulToolkit 快速定位 GsonFormat Gson对象生成 MyBatis Log Plugin MyBatis 显示执行的SQL语句 Free Mybatis plugin MyBatis map和接口快速跳转","categories":[],"tags":[]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-03-08T13:13:15.000Z","updated":"2020-03-08T14:23:49.796Z","comments":true,"path":"2020/03/08/SpringMVC/","link":"","permalink":"http://gushihu1.com/2020/03/08/SpringMVC/","excerpt":"摘要","text":"摘要 SpringMVC","categories":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://gushihu1.com/tags/SpringMVC/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-03-01T12:28:15.000Z","updated":"2020-03-08T13:14:44.409Z","comments":true,"path":"2020/03/01/JDBC/","link":"","permalink":"http://gushihu1.com/2020/03/01/JDBC/","excerpt":"摘要","text":"摘要 JDBC1.1获取连接 数据库url: ==url=“ jdbc:mysql://localhost:3306/数据库名 ”== 配置信息 用户名： 密码： 驱动 1.1.1 配置文件获取连接1234url=jdbc:mysql://localhost/testjdbc?serverTimezone=UTCusername=rootpassword=admindriverClassName=com.mysql.cj.jdbc.Driver 1234567891011121314151617public static Connection getConnection1() throws Exception &#123; //1.读取配置文件中的四个基本信息 InputStream is = GetConnection1.class.getClassLoader().getResourceAsStream(\"配置文件路径\"); Properties pros =new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2.加载驱动 Class.forName(driverClass); //3.获取连接 Connection conn = DriverManager.getConnection(url,user,password); return conn; &#125; 1.2 关闭资源123456789101112131415161718192021222324public static void closeResource1(Connection conn, Statement ps,ResultSet rs) &#123; try &#123; if ((ps != null))&#123; ps.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; try &#123; if (conn != null)&#123; conn.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; try &#123; if (rs != null)&#123; rs.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; 1.3 PreparedStatement和Statement1.3.1 Statement存在的问题 需要拼写SQL语句 存在SQL注入问题 1.3.2 Statement对数据库进行操作123String user = \"张三\";String password = \"zhangsan\";String sql = \"SELECT USER,PASSWORD FROM user_table WHERE USER = '\"+user+\"' AND PASSWORD = '\"+password+\"'\"; 1.3.3 PreparedStatement对数据库进行操作1.3.3.1 增删改1234567891011121314151617//4.预编译SQL语句， String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; PreparedStatement ps = conn.prepareStatement(sql); //5.填充占位符 ps.setString(1,\"哪吒\"); ps.setString(2,\"nezha@qq.com\"); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); java.util.Date date = sdf.parse(\"1000-01-01\"); ps.setDate(3, new Date(date.getTime())); //6.执行操作 ps.execute(); //7.资源的关闭 ps.close(); conn.close(); 1.3.3.2 通用的增删改1234public void PreparedStatementTest()&#123; String sql = \"delete from customers where id = ?\"; update(sql,3,...);//有几个问号，写几个参数 &#125; 12345678910111213141516171819202122public void update(String sql, Object ...args) &#123; Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库 connection = getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 closeResource1(connection,preparedStatement,null); &#125; &#125; 1.3.3.3 通用查询1.3.3.3.1 返回表中的一条数据1234StatementTest st = new StatementTest(); String sql = \"select id,name,email from customers where id=?\"; Customer customer = st.query1(Customer.class, sql, 2); System.out.println(customer); 12345678910111213141516171819202122232425262728293031323334353637383940public &lt;T&gt; T query1(Class&lt;T&gt; clazz,String sql,Object...args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; connection = getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); if (resultSet.next())&#123; T t = clazz.newInstance(); for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125; 1.3.3.3.2 返回多行数据1234StatementTest st = new StatementTest(); String sql = \"select id,name,birth from student where id&lt;?\"; List&lt;Student&gt; list = st.query2(Student.class, sql, 4); list.forEach(System.out::println); 1.3.3.3.3 查所有1234StatementTest st &#x3D; new StatementTest(); String sql &#x3D; &quot;select id,name,birth from student &quot;; List&lt;Student&gt; list &#x3D; st.query2(Student.class, sql); list.forEach(System.out::println); 123456789101112131415161718192021222324252627282930313233343536373839404142public &lt;T&gt; List&lt;T&gt; query2(Class&lt;T&gt; clazz, String sql, Object...args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; connection = getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while (resultSet.next())&#123; T t = clazz.newInstance(); //处理结果集数据中的每一个列：给t对象指定的属性赋值 for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125; 通用特殊值查询 123456789101112131415161718192021//通用特殊值查询 public &lt;E&gt; E getValue(Connection connection,String sql,Object...args) &#123; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt;args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; resultSet = preparedStatement.executeQuery(); if (resultSet.next())&#123; return (E) resultSet.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(null,preparedStatement,resultSet); &#125; return null; &#125; 1.3.3.4 插入图片12345678910public void testInsert() throws Exception&#123; Connection connection = JDBC.getConnection1(); String sql = \"insert into student(id,photo)values (?,?)\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setObject(1,4); FileInputStream is = new FileInputStream(\"F:\\\\red-pagoda-temple-3380967.jpg\"); preparedStatement.setBlob(2,is); preparedStatement.execute(); JDBC.closeResource1(connection,preparedStatement,null); &#125; 1.3.4Statement和PreparedStatement区别 解决了Statement的拼串 解决了SQL注入问题 PreparedStatement可以操作Blob的数据 PreparedStatement可以实现更高效的批量操作 1.4 批量插入 ddBatch() excuteBatch() clearBatch() 1234567891011121314//设置不允许自动提交数据 conn.setAutoCommit(false); for (int i = 1;i &lt;= 10000;i++)&#123; //1.攒SQL ps.addBatch(); if (i % 500 == 0)&#123; //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); &#125; &#125; //4.统一提交 conn.commit(); mysql服务器默认关闭批处理，修改参数,写在配置文件url的后面 1?rewriteBetchedStatements&#x3D;true 不允许自动提交 1.5 事务 当一个事务中执行多个操作时，要么所有的事物==都被提交==，要么放弃所有修改，==整个事务回滚==到最初的状态 数据一旦提交就不可回滚 当一个连接被创建时，默认情况下是自动提交事务 关闭数据库连接，数据就会自动提交 DDL操作一旦执行，都会自动提交，set autocommit = false对DDL不起作用 DML默认情况下，一旦执行，就会自动提交，可以通过 set autocommit = false取消自动提交 使用后需要恢复自动提交状态 1.5.1 考虑事务通用的增删改12345678910111213141516171819202122232425262728293031323334353637383940//模拟转账 public void testWithTx() &#123; Connection connection = null; try &#123; connection = JDBC.getConnection1(); System.out.println(connection.getAutoCommit()); //1.取消数据自动提交 connection.setAutoCommit(false); //操作一 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(connection,sql1,\"AA\"); //模拟网络异常// System.out.println(10/0); //操作二 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(connection,sql2,\"BB\"); //2.提交数据 connection.commit(); System.out.println(\"转账成功\"); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //3.回滚数据 connection.rollback(); System.out.println(\"转账失败\"); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; try &#123; //恢复自动提交状态 connection.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBC.closeResource1(connection,null,null); &#125; &#125; 123456789101112131415161718192021222324public int update(Connection connection,String sql, Object ...args) &#123;// Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库// connection = JDBC.getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 JDBC.closeResource1(null,preparedStatement,null); &#125; return 0; &#125; 1.5.2 事务的ACID属性 原子性 一致性 隔离性 持久性 1.5.3 数据库的并发 脏读 不可重复读 幻读 1.5.4 四种隔离级别 READ UNCOMMITTED (读未提交数据) READ COMMITED (读已提交数据) REPEATABLE READ (可重复读) SERIALIZABLE (序列化) 1.6 升级操作123public class CustomerImpl extends BaseDAO&lt;Customer&gt; implements CustomerDAO&#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public abstract class BaseDAO&lt;T&gt; &#123; private Class&lt;T&gt; clazz = null; &#123; //获取当前BaseDAO的子类继承的父类中的泛型 Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();//获取了父类的泛型参数 clazz = (Class&lt;T&gt;) actualTypeArguments[0]; &#125; //通用的增删改 public int update(Connection connection, String sql, Object ...args) &#123;// Connection connection = null ; PreparedStatement preparedStatement = null; try &#123; //1.连接数据库// connection = JDBC.getConnection1(); //2.预编译的SQL语句，返回PreparedStatement实例 preparedStatement = connection.prepareStatement(sql); //3.填充占位符 for (int i = 0;i &lt; args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; //4.执行 preparedStatement.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //5.关闭资源 JDBC.closeResource1(null,preparedStatement,null); &#125; return 0; &#125; //通用查询 public List&lt;T&gt; query2(Connection connection, String sql, Object...args) &#123;// Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123;// connection = JDBC.getConnection1(); preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt; args.length; i++)&#123; preparedStatement.setObject(i + 1, args[i]); &#125; resultSet = preparedStatement.executeQuery(); //获取结果集的数据元 ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); //获取结果集的列数 int columnCount = resultSetMetaData.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while (resultSet.next())&#123; T t = clazz.newInstance(); //处理结果集数据中的每一个列：给t对象指定的属性赋值 for (int i = 0;i &lt; columnCount;i++) &#123; //获取列值 Object columvalue = resultSet.getObject(i + 1); //获取某个列的列名 String columnName = resultSetMetaData.getColumnName(i+1); //给customer对象指定的某个属性，赋值为value //给customer对象指定的columnName属性，赋值为columvalues,通过反射 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t,columvalue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,preparedStatement,resultSet); &#125; return null; &#125;&#125;//通用特殊值查询 public &lt;E&gt; E getValue(Connection connection,String sql,Object...args) &#123; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; preparedStatement = connection.prepareStatement(sql); for (int i = 0;i &lt;args.length;i++)&#123; preparedStatement.setObject(i + 1,args[i]); &#125; resultSet = preparedStatement.executeQuery(); if (resultSet.next())&#123; return (E) resultSet.getObject(1); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(null,preparedStatement,resultSet); &#125; return null; &#125; 1.7 数据库连接池1.7.1 德鲁伊（druid）123456789101112131415161718public class DruidTest &#123; private static DataSource source; static &#123; try &#123; Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid\"); pros.load(is); source = DruidDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws Exception &#123; Connection connection = source.getConnection(); System.out.println(connection); return connection; &#125;&#125; 1.8 DBUtils123456&lt;!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; 1.8.1 增删改123456789101112131415public void testQueryRunner() throws Exception &#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"insert into customers(id,name ,email ,birth)values(?,?,?,?)\"; int insertCount = runner.update(connection, sql, \"6\",\"蔡徐坤\", \"caixukun@qq.com\", \"1997-01-01\"); System.out.println(\"添加了\"+insertCount+\"条数据\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.2 查询（返回一条记录）123456789101112131415public void testQuery1() throws Exception&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select id,name,email from customers where id = ?\"; BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(connection, sql, handler, 5); System.out.println(customer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; BeanHandler：是ResultBeanHandler接口的实现类，用于封装表中的一条记录 1.8.3 查询（返回多条记录）123456789101112131415public void testQuery2() throws Exception&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select id,name,email from customers where id &lt; ?\"; BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(connection, sql, handler, 5); list.forEach(System.out::println); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.4 查询（特殊返回值）123456789101112131415public void testQuery3()&#123; Connection connection = null; try &#123; QueryRunner runner = new QueryRunner(); connection = DruidTest.getConnection(); String sql = \"select count(*) from customers\"; ScalarHandler handler = new ScalarHandler(); Long count = (Long) runner.query(connection, sql, handler); System.out.println(count); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBC.closeResource1(connection,null,null); &#125; &#125; 1.8.5 关闭资源12345public static void closeResources(Connection connection, Statement statement, ResultSet resultSet) &#123; DbUtils.closeQuietly(connection); DbUtils.closeQuietly(statement); DbUtils.closeQuietly(resultSet); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gushihu1.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://gushihu1.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://gushihu1.com/tags/JDBC/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-29T13:54:25.396Z","updated":"2020-03-01T13:47:04.902Z","comments":true,"path":"2020/02/29/hello-world/","link":"","permalink":"http://gushihu1.com/2020/02/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}